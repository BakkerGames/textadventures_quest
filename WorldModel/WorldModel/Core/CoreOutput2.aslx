<library>
  
  <!-- TO DO: Move this into CoreOutput.aslx when ready for all games to use as the main output method -->
  
  <function name="OutputText" parameters="text">
    <![CDATA[
    Log(text)
    text = ProcessText(text)
    JS.addText("<span style=\"" + GetCurrentTextFormat() + "\">" + text + "</span><br/>")
    ]]>
  </function>

  <function name="GetCurrentTextFormat" type="string">
    // TO DO: Need a way to query Quest options to see if there is a font or colour override
    
    style = ""
    
    font = GetCurrentFontFamily()
    if (LengthOf(font) > 0) {
      style = style + "font-family:" + font + ";"
    }
    
    colour = game.defaultforeground
    if (LengthOf(colour) > 0) {
      style = style + "color:" + colour + ";"
    }
    
    size = game.defaultfontsize
    if (size > 0) {
      style = style + "font-size:" + ToString(size) + "pt;"
    }
    
    return (style)
  </function>

  <function name="ProcessText" type="string" parameters="text">
    return (ProcessTextSection(text, text))
  </function>

  <function name="ProcessTextSection" type="string" parameters="text, fulltext">
    <![CDATA[
    
    containsUnprocessedSection = false
    
    open = Instr(text, "{")
    
    if (open > 0) {
      nestCount = 1
      searchStart = open + 1
      finished = false
      
      while (not finished) {
        nextOpen = Instr(searchStart, text, "{")
        nextClose = Instr(searchStart, text, "}")
      
        if (nextClose > 0) {
          if (nextOpen > 0 and nextOpen < nextClose) {
            nestCount = nestCount + 1
            searchStart = nextOpen + 1
          }
          else {
            nestCount = nestCount - 1
            searchStart = nextClose + 1
            if (nestCount = 0) {
              close = nextClose
              containsUnprocessedSection = true
              finished = true
            }
          }
        }
        else {
          finished = true
        }
      }
    }
    
    if (containsUnprocessedSection) {
      section = Mid(text, open + 1, close - open - 1)
      Log ("Found section: " + section)
      value = ProcessTextCommand(section, fulltext)
      text = Left(text, open - 1) + value + ProcessTextSection(Mid(text, close + 1), fulltext)
    }
    
    return (text)
    ]]>
  </function>

  <function name="ProcessTextCommand" type="string" parameters="section, fulltext">
    if (StartsWith(section, "if ")) {
      // TO DO
      return ("(if)")
    }
    else if (StartsWith(section, "object:")) {
      // TO DO
      return ("(object)")
    }
    else if (StartsWith(section, "exit:")) {
      // TO DO
      return ("(exit)")
    }
    else if (StartsWith(section, "command:")) {
      // TO DO
      return ("(command)")
    }
    else if (StartsWith(section, "once:")) {
      return (ProcessTextCommand_Once(section, fulltext))
    }
    else if (StartsWith(section, "random:")) {
      // TO DO
      return ("(random)")
    }
    else {
      return ("{" + section + "}")
    }
  </function>

  <function name="ProcessTextCommand_Once" type="string" parameters="section, fulltext">
    if (not HasAttribute(game, "textprocessor_seen")) {
      game.textprocessor_seen = NewStringList()
    }
    if (not ListContains(game.textprocessor_seen, fulltext)) {
      // TO DO: Would be better to have a dictionary on the game, with keys as fulltext, and values as section.
      // Until then, this implementation only allows one {once} section per block of text.
      list add (game.textprocessor_seen, fulltext)
      return (ProcessText(Mid(section, 6)))
    }
    else {
      return ("")
    }
  </function>
</library>