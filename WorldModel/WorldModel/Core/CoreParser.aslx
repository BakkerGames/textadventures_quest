<library>
  <function name="CompareNames" parameters="name, value, obj, fullmatches, partialmatches">
    if (name = value) {
      if (not ListContains(fullmatches, obj)) {
        list add (fullmatches, obj)
      }
    }
    else {
      if (StartsWith(name, value)) {
        if (not ListContains(partialmatches, obj)) {
          list add (partialmatches, obj)
        }
      }
      else {
        // check if input matches the start of any word in the name
        if (Instr(name, " " + value) > 0) {
          if (not ListContains(partialmatches, obj)) {
            list add (partialmatches, obj)
          }
        }
      }
    }
  </function>
  
  <function name="GenerateMenuChoices" parameters="dictionary, objects">
    foreach (obj, objects) {
      dictionary add (dictionary, obj.name, GetDisplayAlias(obj))
    }
  </function>

  <function name="ResolveName" parameters="variable, value, objtype" type="object">
    <![CDATA[
    result = ResolveNameInternal(variable, value, objtype)
    if (result <> null) {
      return (result)
    }
    else {
      foreach (prefix, game.parserignoreprefixes) {
        if (StartsWith(value, prefix + " ")) {
          result = ResolveNameInternal(variable, Mid(value, LengthOf(prefix) + 1), objtype)
        }
      }
      return (result)
    }
    ]]>
  </function>
  
  <function name="ResolveNameInternal" parameters="variable, value, objtype" type="object">
    <![CDATA[
    fullmatches = NewObjectList()
    partialmatches = NewObjectList()
    
    if (objtype = "object") {
      scope = ScopeVisible()
    }
    else if (objtype = "exit") {
      scope = ScopeExitsAll()
    }
    
    value = Trim(value)
    
    foreach (obj, scope) {
      name = LCase(GetDisplayAlias(obj))
      CompareNames (name, value, obj, fullmatches, partialmatches)
      if (obj.alt <> null) {
        foreach (altname, obj.alt) {
          CompareNames (LCase(altname), value, obj, fullmatches, partialmatches)
        }
      }
    }
    
    if (game.lastobjects <> null) {
      foreach (obj, game.lastobjects) {
        CompareNames (LCase(obj.article), value, obj, fullmatches, partialmatches)
        CompareNames (LCase(obj.gender), value, obj, fullmatches, partialmatches)
      }
    }
    
    if (ListCount(fullmatches) = 1) {
      return (ListItem(fullmatches, 0))
    }
    else if (ListCount(fullmatches) = 0 and ListCount(partialmatches) = 1) {
      return (ListItem(partialmatches, 0))
    }
    else if (ListCount(fullmatches) + ListCount(partialmatches) = 0) {
      return (null)
    }
    else {
      menu = NewStringDictionary()
      GenerateMenuChoices(menu, fullmatches)
      GenerateMenuChoices(menu, partialmatches)
      
      player.currentcommandpendingvariable = variable
      
      show menu (DynamicTemplate("DisambiguateMenu", value), menu, true) {
        varname = player.currentcommandpendingvariable
        player.currentcommandpendingvariable = null
        if (result <> null) {
          AddToResolvedNames(varname, GetObject(result))
        }
      }
      
      //result = ShowMenu(DynamicTemplate("DisambiguateMenu", value), menu, true)
      //if (result = null) {
      //  return (null)
      //}
      //else {
      //  return (GetObject(result))
      //}
      
      return (null)
    }
    ]]>
  </function>

  <function name="ResolveNameList" parameters="value, scope, objtype, resultdictionary" type="objectlist">
    <![CDATA[
    result = NewObjectList()
    isfinished = false
    
    inputlist = Split(value, ",")
    foreach (inputbase, inputlist) {
      inputlist2 = Split(inputbase, Template("And"))
      
      foreach (input, inputlist2) {
        if (not isfinished) {
          newitem = ResolveNameListItem(Trim(input), scope, objtype, resultdictionary)
          if (newitem = null) {
            isfinished = true
            result = null
          }
          else {
            result = ListCombine(result, newitem)
          }
        }
      }
    }
    
    if (result <> null) {
      if (ListCount(result) > 1) {
        if (not DictionaryContains(resultdictionary, "multiple")) {
          dictionary add (resultdictionary, "multiple", true)
        }    
      }
    }
    return (result)
    ]]>
  </function>

  <function name="ResolveNameListItem" parameters="value, scope, objtype, resultdictionary" type="objectlist">
    if (ListContains(game.allobjects, value)) {
      if (not DictionaryContains(resultdictionary, "multiple")) {
        dictionary add (resultdictionary, "multiple", true)
      }
      return (scope)
    }
    else {
      // TO DO: First parameter is variable name
      object = ResolveName("", value, objtype)
      if (object = null) {
        return (null)
      }
      else {
        result = NewObjectList()
        list add (result, object)
        return (result)
      }
    }
  </function>

  <function name="HandleCommand" parameters="command">
    commands = Split(command, ".")
    if (ListCount(commands) = 1) {
      HandleSingleCommand (Trim(command))
    }
    else {
      player.commandqueue = commands
      HandleNextCommandQueueItem
    }
  </function>

  <function name="HandleNextCommandQueueItem">
    if (TypeOf(player, "commandqueue") = "stringlist") {
      queuelength = ListCount(player.commandqueue)
      if (queuelength > 0) {
        thiscommand = Trim(StringListItem(player.commandqueue, 0))
        if (queuelength = 1) {
          player.commandqueue = null
        }
        else {
          newqueue = NewStringList()
          for (i, 1, queuelength - 1) {
            list add (newqueue, StringListItem(player.commandqueue, i))
          }
          player.commandqueue = newqueue
        }
        if (LengthOf(thiscommand) > 0) {
          HandleSingleCommand (thiscommand)
        }
        else {
          HandleNextCommandQueueItem
        }
      }
    }
  </function>

  <function name="HandleSingleCommand" parameters="command">
    candidates = NewObjectList()
    foreach (cmd, ScopeCommands()) {
      if (IsRegexMatch(cmd.pattern, command)) {
        list add (candidates, cmd)
      }
    }
    
    maxstrength = -1
    thiscommand = null
        
    foreach (candidate, candidates) {
      strength = GetMatchStrength(candidate.pattern, command)
      // favour commands defined later, so an author can override a library command
      if (strength >= maxstrength) {
        thiscommand = candidate
        maxstrength = strength
      }
    }
    
    if (thiscommand = null) {
      msg (Template("UnrecognisedCommand"))
    }
    else {
      varlist = Populate(thiscommand.pattern, command)
      HandleSingleCommandPattern (command, thiscommand, varlist)
    }
    RunTurnScripts
    UpdateStatusAttributes
    
    // this call should be moved to UnrecognisedCommand above only,
    // as HandleSingleCommandPattern must be responsible for processing the next command only when it is ready
    HandleNextCommandQueueItem
  </function>

  <function name="HandleSingleCommandPattern" parameters="command, thiscommand, varlist">
    // current command string
    player.currentcommand = command
    
    // current command object
    player.currentcommandpattern = thiscommand
    
    // string dictionary of variables, e.g. object1="book"; object2="table"
    player.currentcommandvarlist = varlist
    
    // string list of variables left to resolve
    player.currentcommandvarlistqueue = NewStringList()
    foreach (key, varlist) {
      list add (player.currentcommandvarlistqueue, key)
    }
    
    // dictionary of resolved elements, e.g. object1=book_object; object2=table_object
    player.currentcommandresolvedelements = NewDictionary()
    
    // list of resolved elements, e.g. book_object; table_object
    player.currentcommandresolvedobjects = NewObjectList()
    
    player.currentcommandunresolvedobject = null
    ResolveNextName
  </function>

  <function name="ResolveNextName">
    <![CDATA[
    resolvedall = false
    queuetype = TypeOf(player, "currentcommandvarlistqueue")
    if (queuetype = "stringlist") {
      queuelength = ListCount(player.currentcommandvarlistqueue)
      if (queuelength > 0) {
      
        // Pop next variable off the queue
        var = StringListItem(player.currentcommandvarlistqueue, 0)
        if (queuelength = 1) {
          player.currentcommandvarlistqueue = null
        }
        else {
          newqueue = NewStringList()
          for (i, 1, queuelength - 1) {
            list add (newqueue, StringListItem(player.currentcommandvarlistqueue, i))
          }
          player.currentcommandvarlistqueue = newqueue
        }
        
        // Resolve variable
        value = LCase(StringDictionaryItem(player.currentcommandvarlist, var))
        result = null
          
        if (StartsWith(var, "object")) {
          if (HasDelegateImplementation(player.currentcommandpattern, "multiple")) {
            result = ResolveNameList(value, RunDelegateFunction(player.currentcommandpattern, "multiple"), "object", player.currentcommandresolvedelements)
            if (result <> null) {
              foreach (obj, result) {
                list add (player.currentcommandresolvedobjects, obj)
              }
            }
          }
          else {
            result = ResolveName(var, value, "object")
            if (result <> null) {
              list add (player.currentcommandresolvedobjects, result)
            }
          }
        }
        else if (StartsWith(var, "exit")) {
          result = ResolveName(var, value, "exit")
        }
        else if (StartsWith(var, "text")) {
          result = StringDictionaryItem(player.currentcommandvarlist, var)
        }
        else {
          error ("Unhandled command variable '" + var + "'")
        }
        
        // at this point, ResolveName has returned - either an object name, unresolved, or pending
            
        if (result = null) {
        
          if (LengthOf(GetString(player, "currentcommandpendingvariable")) = 0) {
            // TO DO: these need to be saved so we can use "oops"
            resolved = false
            unresolvedobject = value
            unresolvedkey = var
            msg ("Unresolved")
          }
          else {
            msg ("pending")
          }
        }
        else {
          AddToResolvedNames(var, result)
        }
      }
      else {
        resolvedall = true
      }
    }
    else if (queuetype = "null") {
      resolvedall = true
    }
    else {
      error ("Invalid queue type")
    }
    
    if (resolvedall) {
      // TO DO: game.lastobjects should be player.lastobjects
      game.lastobjects = player.currentcommandresolvedobjects
      
      if (not DictionaryContains(player.currentcommandresolvedelements, "multiple")) {
        dictionary add (player.currentcommandresolvedelements, "multiple", false)
      }
      
      if (not GetBoolean(player.currentcommandpattern, "isundo")) {
        if (LengthOf(player.currentcommand) > 0) {
          start transaction (player.currentcommand)
        }
      }
      if (not GetBoolean(player.currentcommandpattern, "isoops")) {
        // TO DO: game.unresolved* should be player.unresolved*
        game.unresolvedcommand = null
        game.unresolvedcommandvarlist = null
        game.unresolvedcommandkey = null
      }
      do (player.currentcommandpattern, "script", player.currentcommandresolvedelements)
    }
    ]]>
  </function>

  <function name="AddToResolvedNames" parameters="var, result">
    dictionary add(player.currentcommandresolvedelements, var, result)
    ResolveNextName
  </function>

  <!--
  <function name="HandleSingleCommandPatternOld" parameters="command, thiscommand, varlist">
    <![CDATA[
    resolved = true
    resolvedelements = NewDictionary()
    resolvedobjects = NewObjectList()
    unresolvedobject = null
    
    foreach (var, varlist) {
      if (resolved) {
        value = LCase(StringDictionaryItem(varlist, var))
        result = null
          
        if (StartsWith(var, "object")) {
          if (HasDelegateImplementation(thiscommand, "multiple")) {
            result = ResolveNameList(value, RunDelegateFunction(thiscommand, "multiple"), "object", resolvedelements)
            if (result <> null) {
              foreach (obj, result) {
                list add (resolvedobjects, obj)
              }
            }
          }
          else {
            result = ResolveName(value, "object")
            if (result <> null) {
              list add (resolvedobjects, result)
            }
          }
        }
        else if (StartsWith(var, "exit")) {
          result = ResolveName(value, "exit")
        }
        else if (StartsWith(var, "text")) {
          result = StringDictionaryItem(varlist, var)
        }
        else {
          error ("Unhandled command variable '" + var + "'")
        }
            
        if (result = null) {
          resolved = false
          unresolvedobject = value
          unresolvedkey = var
        }
        else {
          dictionary add(resolvedelements, var, result)
        }
      }
    }
    
    game.lastobjects = resolvedobjects
      
    if (not DictionaryContains(resolvedelements, "multiple")) {
      dictionary add (resolvedelements, "multiple", false)
    }
      
    if (resolved) {
      if (not GetBoolean(thiscommand, "isundo")) {
        if (LengthOf(command) > 0) {
          start transaction (command)
        }
      }
      if (not GetBoolean(thiscommand, "isoops")) {
        game.unresolvedcommand = null
        game.unresolvedcommandvarlist = null
        game.unresolvedcommandkey = null
      }
      do (thiscommand, "script", resolvedelements)
    }
    else {
      if (HasString(thiscommand, "unresolved")) {
        if (ListCount(varlist) > 1) {
          msg (thiscommand.unresolved + " (" + unresolvedobject + ")")
        }
        else {
          msg (thiscommand.unresolved)
        }
      }
      else {
        if (ListCount(varlist) > 1) {
          msg (Template("UnresolvedObject") + " (" + unresolvedobject + ")")
        }
        else {
          msg (Template("UnresolvedObject"))
        }
      }
      game.unresolvedcommand = thiscommand
      game.unresolvedcommandvarlist = varlist
      game.unresolvedcommandkey = unresolvedkey
    }
    ]]>
  </function>
  -->
  
  <type name="defaultverb">
    <script type="script">
      <![CDATA[
      switch (TypeOf(object, this.property)) {
        case ("script") {
          do (object, this.property)
        }
        case ("string") {
          msg (GetString(object, this.property))
        }
        case ("null") {
          if (this.defaulttext <> null) {
            msg (this.defaulttext)
          }
          else if (this.defaulttemplate <> null) {
            msg (DynamicTemplate(this.defaulttemplate, object))
          }
          else if (this.defaultexpression <> null) {
            params = NewDictionary()
            dictionary add (params, "object", object)
            msg (Eval(this.defaultexpression, params))
          }
          else {
            error ("No verb response defined")
          }
        }
        default {
          error ("No verb response defined")
        }
      }
      ]]>
    </script>
  </type>
</library>