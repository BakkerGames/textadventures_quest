<library>
  <function name="CompareNames" parameters="name, value, obj, fullmatches, partialmatches">
    if (name = value) {
      if (not ListContains(fullmatches, obj)) {
        list add (fullmatches, obj)
      }
    }
    else {
      if (StartsWith(name, value)) {
        if (not ListContains(partialmatches, obj)) {
          list add (partialmatches, obj)
        }
      }
      else {
        // check if input matches the start of any word in the name
        if (Instr(name, " " + value) > 0) {
          if (not ListContains(partialmatches, obj)) {
            list add (partialmatches, obj)
          }
        }
      }
    }
  </function>
  
  <function name="GenerateMenuChoices" parameters="dictionary, objects">
    foreach (obj, objects) {
      dictionary add (dictionary, obj.name, GetDisplayAlias(obj))
    }
  </function>
  
  <!--
  ResolveName function
  Parameters: variable    - for single object commands. If we show a menu, key to populate in player.currentcommandresolvedelements.
                            Leave blank for multi-object commands. In this case, we add the object to player.currentcommandpendingobjectlist
              value       - string to resolve to an object e.g. "book", "south"
              objtype     - object type, must be "object" or "exit"
  -->

  <function name="ResolveName" parameters="variable, value, objtype" type="object">
    <![CDATA[
    result = ResolveNameInternal(variable, value, objtype)
    if (result <> null) {
      return (result)
    }
    else {
      // TO DO: Check this behaviour. We only want to try ignoring prefixes if we have definitely got an unresolved name.
      foreach (prefix, game.parserignoreprefixes) {
        if (StartsWith(value, prefix + " ")) {
          result = ResolveNameInternal(variable, Mid(value, LengthOf(prefix) + 1), objtype)
        }
      }
      
      if (result = null and LengthOf(variable) = 0 and not GetBoolean(player, "currentcommandmultiobjectpending")) {
        UnresolvedCommand (value, player.currentcommandpendingvariable)
      }
      
      return (result)
    }
    ]]>
  </function>
  
  <function name="ResolveNameInternal" parameters="variable, value, objtype" type="object">
    <![CDATA[
    fullmatches = NewObjectList()
    partialmatches = NewObjectList()
    player.currentcommandmultiobjectpending = false
    
    if (objtype = "object") {
      scope = ScopeVisible()
    }
    else if (objtype = "exit") {
      scope = ScopeExitsAll()
    }
    
    value = Trim(value)
    
    foreach (obj, scope) {
      name = LCase(GetDisplayAlias(obj))
      CompareNames (name, value, obj, fullmatches, partialmatches)
      if (obj.alt <> null) {
        foreach (altname, obj.alt) {
          CompareNames (LCase(altname), value, obj, fullmatches, partialmatches)
        }
      }
    }
    
    if (game.lastobjects <> null) {
      foreach (obj, game.lastobjects) {
        CompareNames (LCase(obj.article), value, obj, fullmatches, partialmatches)
        CompareNames (LCase(obj.gender), value, obj, fullmatches, partialmatches)
      }
    }
    
    if (ListCount(fullmatches) = 1) {
      return (ListItem(fullmatches, 0))
    }
    else if (ListCount(fullmatches) = 0 and ListCount(partialmatches) = 1) {
      return (ListItem(partialmatches, 0))
    }
    else if (ListCount(fullmatches) + ListCount(partialmatches) = 0) {
      return (null)
    }
    else {
      menu = NewStringDictionary()
      GenerateMenuChoices(menu, fullmatches)
      GenerateMenuChoices(menu, partialmatches)
      
      if (LengthOf(variable) > 0) {
        // single object command, so after showing the menu, add the object to player.currentcommandresolvedelements
        player.currentcommandpendingvariable = variable
      
        show menu (DynamicTemplate("DisambiguateMenu", value), menu, true) {
          varname = player.currentcommandpendingvariable
          player.currentcommandpendingvariable = null
          if (result <> null) {
            AddToResolvedNames(varname, GetObject(result))
          }
        }
      }
      else {
        // multi-object command, so after showing the menu, add the object to the list
        
        player.currentcommandmultiobjectpending = true
        
        show menu (DynamicTemplate("DisambiguateMenu", value), menu, true) {
          if (result <> null) {
            list add (player.currentcommandpendingobjectlist, GetObject(result))
            ResolveNextNameListItem
          }
        }        
      }
      
      return (null)
    }
    ]]>
  </function>
  
  <!--
  ResolveNameList function
  Parameters: value     - value to resolve into the object list e.g. "book", "all", "newspaper, book and magazine"
              scope     - objectlist to use if value is "all"
              objtype   - object type, must be "object" or "exit"
              
  Populates player.currentcommandpendingobjectlist with the object names.
  Adds "multiple" entry to player.currentcommandresolvedelements if there is more than one element.
  -->

  <function name="ResolveNameList" parameters="value, scope, objtype">
    <![CDATA[
    player.currentcommandpendingobjectlist = NewObjectList()
    player.currentcommandpendingobjectlistunresolved = NewStringList()
    player.currentcommandpendingobjectscope = scope
    player.currentcommandpendingobjecttype = objtype
    
    inputlist = Split(value, ",")
    foreach (inputbase, inputlist) {
      inputlist2 = Split(inputbase, " " + Template("And") + " ")
      foreach (input, inputlist2) {
        list add (player.currentcommandpendingobjectlistunresolved, input)
      }
    }
    ResolveNextNameListItem
    ]]>
  </function>

  <function name="ResolveNextNameListItem">
    resolvedall = false
    if (TypeOf(player, "currentcommandpendingobjectlistunresolved") = "stringlist") {
      queuelength = ListCount(player.currentcommandpendingobjectlistunresolved)
      if (queuelength > 0) {
        thisitem = Trim(StringListItem(player.currentcommandpendingobjectlistunresolved, 0))
        if (queuelength = 1) {
          player.currentcommandpendingobjectlistunresolved = null
        }
        else {
          newqueue = NewStringList()
          for (i, 1, queuelength - 1) {
            list add (newqueue, StringListItem(player.currentcommandpendingobjectlistunresolved, i))
          }
          player.currentcommandpendingobjectlistunresolved = newqueue
        }
        
        ResolveNameListItem(Trim(thisitem))
      }
      else {
        resolvedall = true
      }
    }
    else {
      resolvedall = true
    }
    
    if (resolvedall) {
      ResolveNameListItemFinished(player.currentcommandpendingobjectlist)
    }
  </function>

  <function name="ResolveNameListItem" parameters="value">
    <![CDATA[
    if (ListContains(game.allobjects, value)) {
      // value is "all"
      
      if (not DictionaryContains(player.currentcommandresolvedelements, "multiple")) {
        dictionary add (player.currentcommandresolvedelements, "multiple", true)
      }
      ResolveNameListItemFinished (player.currentcommandpendingobjectscope)
    }
    else {
      object = ResolveName("", value, player.currentcommandpendingobjecttype)
      if (object <> null) {
        list add (player.currentcommandpendingobjectlist, object)
        ResolveNextNameListItem
      }
    }
    ]]>
  </function>

  <function name="ResolveNameListItemFinished" parameters="result">
    <![CDATA[
    if (ListCount(result) > 1) {
      if (not DictionaryContains(player.currentcommandresolvedelements, "multiple")) {
        dictionary add (player.currentcommandresolvedelements, "multiple", true)
      }
    }
    
    AddToResolvedNames(player.currentcommandpendingvariable, result)
    ]]>
  </function>

  <function name="HandleCommand" parameters="command">
    msg ("")
    msg ("> " + SafeXML(command))
    commands = Split(command, ".")
    if (ListCount(commands) = 1) {
      HandleSingleCommand (Trim(command))
    }
    else {
      player.commandqueue = commands
      HandleNextCommandQueueItem
    }
  </function>

  <function name="HandleNextCommandQueueItem">
    if (TypeOf(player, "commandqueue") = "stringlist") {
      queuelength = ListCount(player.commandqueue)
      if (queuelength > 0) {
        thiscommand = Trim(StringListItem(player.commandqueue, 0))
        if (queuelength = 1) {
          player.commandqueue = null
        }
        else {
          newqueue = NewStringList()
          for (i, 1, queuelength - 1) {
            list add (newqueue, StringListItem(player.commandqueue, i))
          }
          player.commandqueue = newqueue
        }
        if (LengthOf(thiscommand) > 0) {
          HandleSingleCommand (thiscommand)
        }
        else {
          HandleNextCommandQueueItem
        }
      }
    }
  </function>

  <function name="HandleSingleCommand" parameters="command">
    <![CDATA[
    candidates = NewObjectList()
    foreach (cmd, ScopeCommands()) {
      if (IsRegexMatch(cmd.pattern, command, cmd.name)) {
        list add (candidates, cmd)
      }
    }
    
    maxstrength = -1
    thiscommand = null
        
    foreach (candidate, candidates) {
      strength = GetMatchStrength(candidate.pattern, command, candidate.name)
      // favour commands defined later, so an author can override a library command...
      if (strength >= maxstrength) {
        // ... except if the command defined later (candidate) has no parent, and the current best
        // match (thiscommand) does have a parent. We want to favour any commands defined in rooms
        // over global candidates.
        skip = false
        if (thiscommand <> null) {
          if (thiscommand.parent <> null and candidate.parent = null) {
            skip = true
          }
        }
        if (not skip) {
          thiscommand = candidate
          maxstrength = strength
        }
      }
    }
    
    if (thiscommand = null) {
      msg (Template("UnrecognisedCommand"))
      HandleNextCommandQueueItem
    }
    else {
      varlist = Populate(thiscommand.pattern, command, thiscommand.name)
      HandleSingleCommandPattern (command, thiscommand, varlist)
    }
    ]]>
  </function>

  <function name="FinishTurn">
    RunTurnScripts
    UpdateStatusAttributes
  </function>

  <function name="HandleSingleCommandPattern" parameters="command, thiscommand, varlist">
    // current command string
    player.currentcommand = command
    
    // current command object
    player.currentcommandpattern = thiscommand
    
    // string dictionary of variables, e.g. object1="book"; object2="table"
    player.currentcommandvarlist = varlist
    
    // string list of variables left to resolve
    player.currentcommandvarlistqueue = NewStringList()
    foreach (key, varlist) {
      list add (player.currentcommandvarlistqueue, key)
    }
    
    // dictionary of resolved elements, e.g. object1=book_object; object2=table_object
    player.currentcommandresolvedelements = NewDictionary()
    
    // list of resolved elements, e.g. book_object; table_object
    player.currentcommandresolvedobjects = NewObjectList()
    
    player.currentcommandunresolvedobject = null
    player.currentcommandpendingvariable = null
    ResolveNextName
  </function>

  <function name="ResolveNextName">
    <![CDATA[
    resolvedall = false
    queuetype = TypeOf(player, "currentcommandvarlistqueue")
    if (queuetype = "stringlist") {
      queuelength = ListCount(player.currentcommandvarlistqueue)
      if (queuelength > 0) {
      
        // Pop next variable off the queue
        var = StringListItem(player.currentcommandvarlistqueue, 0)
        if (queuelength = 1) {
          player.currentcommandvarlistqueue = null
        }
        else {
          newqueue = NewStringList()
          for (i, 1, queuelength - 1) {
            list add (newqueue, StringListItem(player.currentcommandvarlistqueue, i))
          }
          player.currentcommandvarlistqueue = newqueue
        }
        
        // Resolve variable
        value = LCase(StringDictionaryItem(player.currentcommandvarlist, var))
        
        if (value <> "") {
          result = null
          resolvinglist = false
          
          if (StartsWith(var, "object")) {
            if (HasDelegateImplementation(player.currentcommandpattern, "multiple")) {
              player.currentcommandpendingobjectlist = NewObjectList()
              player.currentcommandpendingvariable = var
              ResolveNameList(value, RunDelegateFunction(player.currentcommandpattern, "multiple"), "object")
              resolvinglist = true
            }
            else {
              result = ResolveName(var, value, "object")
            }
          }
          else if (StartsWith(var, "exit")) {
            result = ResolveName(var, value, "exit")
          }
          else if (StartsWith(var, "text")) {
            result = StringDictionaryItem(player.currentcommandvarlist, var)
          }
          else {
            error ("Unhandled command variable '" + var + "'")
          }
        
          // at this point, ResolveName has returned - either an object name, unresolved, or pending
            
          if (result = null) {
            if ((not resolvinglist) and LengthOf(GetString(player, "currentcommandpendingvariable")) = 0) {
              UnresolvedCommand(value, var)
            }
          }
          else {
            AddToResolvedNames(var, result)
          }
        }
        else {
          ResolveNextName
        }
      }
      else {
        resolvedall = true
      }
    }
    else if (queuetype = "null") {
      resolvedall = true
    }
    else {
      error ("Invalid queue type")
    }
    
    if (resolvedall) {
      // TO DO: game.lastobjects should be player.lastobjects
      game.lastobjects = player.currentcommandresolvedobjects
      
      if (not DictionaryContains(player.currentcommandresolvedelements, "multiple")) {
        dictionary add (player.currentcommandresolvedelements, "multiple", false)
      }
      
      if (not GetBoolean(player.currentcommandpattern, "isundo")) {
        if (LengthOf(player.currentcommand) > 0) {
          start transaction (player.currentcommand)
        }
      }
      if (not GetBoolean(player.currentcommandpattern, "isoops")) {
        // TO DO: game.unresolved* should be player.unresolved*
        game.unresolvedcommand = null
        game.unresolvedcommandvarlist = null
        game.unresolvedcommandkey = null
      }
      do (player.currentcommandpattern, "script", player.currentcommandresolvedelements)
      HandleNextCommandQueueItem
    }
    ]]>
  </function>

  <function name="AddToResolvedNames" parameters="var, result">
    if (TypeOf(result) = "object") {
      if (result.type = "object") {
        list add (player.currentcommandresolvedobjects, result)
      }
    }
    else if (TypeOf(result) = "objectlist") {
      foreach (obj, result) {
        if (obj.type = "object") {
          list add (player.currentcommandresolvedobjects, obj)
        }
      }
    }
    dictionary add(player.currentcommandresolvedelements, var, result)
    ResolveNextName
  </function>

  <function name="UnresolvedCommand" parameters="objectname, varname">
    // TO DO: Update names below, we don't need these two variables
    unresolvedobject = objectname
    unresolvedkey = varname
    
    if (HasString(player.currentcommandpattern, "unresolved")) {
      if (ListCount(player.currentcommandvarlist) > 1) {
        msg (player.currentcommandpattern.unresolved + " (" + unresolvedobject + ")")
      }
      else {
        msg (player.currentcommandpattern.unresolved)
      }
    }
    else {
      if (ListCount(player.currentcommandvarlist) > 1) {
        msg (Template("UnresolvedObject") + " (" + unresolvedobject + ")")
      }
      else {
        msg (Template("UnresolvedObject"))
      }
    }
    game.unresolvedcommand = player.currentcommandpattern
    game.unresolvedcommandvarlist = player.currentcommandvarlist
    game.unresolvedcommandkey = unresolvedkey
  </function>
  
  <type name="defaultverb">
    <separator>with</separator>
    <script type="script">
      <![CDATA[
      switch (TypeOf(object, this.property)) {
        case ("script") {
          do (object, this.property)
        }
        case ("string") {
          msg (GetString(object, this.property))
        }
        case ("scriptdictionary") {
          handled = false
          if (IsDefined("object2")) {
            if (object2 <> null) {
              // TO DO: Two-object verb with two objects supplied
              handled = true
            }
          }
          if (not handled) {
            // TO DO: Two-object verb with one objects supplied
          }
        }
        case ("null") {
          if (this.defaulttext <> null) {
            msg (this.defaulttext)
          }
          else if (this.defaulttemplate <> null) {
            msg (DynamicTemplate(this.defaulttemplate, object))
          }
          else if (this.defaultexpression <> null) {
            params = NewDictionary()
            dictionary add (params, "object", object)
            msg (Eval(this.defaultexpression, params))
          }
          else {
            error ("No verb response defined")
          }
        }
        default {
          error ("No verb response defined")
        }
      }
      ]]>
    </script>
  </type>
</library>